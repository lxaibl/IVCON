/******************************************************************************/
// Author:  John Burkardt
// Change: 04 Mar 2007 Tomasz Lis adjusted to new core

// Purpose:
//   Metthods for support of SGI Inventor files

// A list of supported elements follows. Please modify if you'll enhance something.
// Format support note - reading:
// - unknown
// Format support note - writing:
// - Full 32-bit vertices support
// - Full 32-bit faces support, unlimited face order
// - No meshes support
// - Partial materials support (untested)
// - One texture support
// - Texture UV support (per vertex)
// - No camera/view support
// - No Environment or lights support
// - No shapes support (disabled because of error)

/*
   NOTE: support of this format is unfinished, it probably won't work.
*/

/*
Example:

#Inventor V2.0 ascii

Separator {
Info {
string "Inventor file generated by IVCON.
Original data in file cube.iv."
}
Separator {
LightModel {
model PHONG
}
MatrixTransform { matrix
0.9  0.0  0.0  0.0
0.0 -0.9  0.0  0.0
0.0  0.0 -1.5  0.0
0.0  0.0  0.0  1.0
}
Material {
ambientColor  0.2 0.2 0.2
diffuseColor  [
0.8 0.8 0.8,
0.7 0.1 0.1,
0.1 0.8 0.2,
]
emissiveColor 0.0 0.0 0.0
specularColor 0.0 0.0 0.0
shininess     0.2
transparency  [
0.0, 0.5, 1.0,
]
}
Texture2 {
filename      "fred.rgb"
wrapS         REPEAT
wrapT         REPEAT
model         MODULATE
blendColor    0.0 0.0 0.0
}

MaterialBinding {
value PER_VERTEX_INDEXED
}
NormalBinding {
value PER_VERTEX_INDEXED
}
TextureCoordinateBinding {
value PER_VERTEX_INDEXED
}

ShapeHints {
vertexOrdering COUNTERCLOCKWISE
shapeType UNKNOWN_SHAPE_TYPE
faceType CONVEX
creaseAngle 6.28319
}

Coordinate3 {
point [
8.59816       5.55317      -3.05561,
8.59816       2.49756      0.000000E+00,
...etc...
2.48695       2.49756      -3.05561,
]
}

Normal {
vector [
0.71 0.71 0.0,
...etc...
0.32 0.32 0.41,
]
}

TextureCoordinate2 {
point [
0.0  1.0,
0.1, 0.8,
...etc...
0.4  0.7,
]
}

IndexedLineSet {
coordIndex [
0,    1,    2,   -1,
3,    4,    5,   -1,
7,    8,    9,   -1,
...etc...
189,  190,  191,   -1,
]
materialIndex [
0,    0,    0,   -1,
1,    1,    1,   -1,
2,    2,    2,   -1,
...etc...
64,   64,   64,   -1,
]
}

IndexedFaceSet {
coordIndex [
0,    1,    2,   -1,
3,    4,    5,   -1,
7,    8,    9,   -1,
...etc...
189,  190,  191,   -1,
]
materialIndex [
0,    0,    0,   -1,
1,    1,    1,   -1,
2,    2,    2,   -1,
...etc...
64,   64,   64,   -1,
]
normalIndex [
0,    0,    0,   -1,
1,    1,    1,   -1,
2,    2,    2,   -1,
...etc...
64,   64,   64,   -1,
]
textureCoordIndex [
0,    0,    0,   -1,
1,    1,    1,   -1,
2,    2,    2,   -1,
...etc...
64,   64,   64,   -1,
]
}

IndexedTriangleStripSet {
vertexProperty VertexProperty {
vertex [ x y z,
...
x y z ]
normal [ x y z,
...
x y z ]
materialBinding OVERALL
normalBinding PER_VERTEX_INDEXED
}
coordIndex [
i, j, k, l, m, -1,
n, o, p, q, r, s, t, u, -1,
v, w, x, -1
..., -1 ]
normalIndex -1
}

}
}
*/
//Copying and copyrights:
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2 of the License, or
//   (at your option) any later version.
/******************************************************************************/

#include "ivconv.h"
#include <cstring>

struct IV_READER
{
    //current level in hierarchical file structure
    long level;
    //names of levels from top to current
    array<NameItm> llevel;
    //num of faces before the reading
    unsigned long face_num_old;
    unsigned long vertex_num_old;
    // variables used to read normal vertices at right indexes
    int   iface_norm;
    int   ivert_norm;
    //parameters for parsing line readed from file
	int   nlbrack;
	int   nrbrack;
	char  word[LINE_MAX_LEN];
    char *next;
    IV_READER(){ level=0;llevel[0]=NameItm();nlbrack=0;nrbrack=0;face_num_old=0;
                  strcpy(word," ");next=word; };
};
/******************************************************************************/

bool IVCONV::iv_read ( FILE *filein )

/******************************************************************************/
/*
Purpose:
IV_READ reads graphics information from an Inventor file.

    Author: John Burkardt
    Modified: 01 July 1999
	Modified: 08 Mar 2007 Tomasz Lis rewritten for new IVCON core
*/
{
	char  c;
	int   i;
	int   icol;
	int   icolor;
	int   icface;
	int   inormface;
	int   iface_num;
	int   irow;
	int   iuv;
	int   ivert;
	int   ix;
	int   ixyz;
	int   iy;
	int   iz;
	int   j;
	int   jval;
	int   level;
	int   nlbrack;
	int   nrbrack;
	int   nu;
	int   vertex_num_old;
	int   shape_num2;
	int   face_num2;
	int   normal_num_temp;
	int   text_numure_temp;
	int   nv;
	int   result;
	float rval;
	float xvec[3];

    array<NameItm> llevel;          // lights in scene
    array<vec3>  normal_temp;
    array<vec2>	texture_temp;
    char   material_binding[LINE_MAX_LEN];
    char   texture_binding[LINE_MAX_LEN];
    array<vec3>  rgbcolor;
    unsigned long color_num=0;
    array<NameItm> ttexture;

	icface = 0;
	icol = -1;
	inormface = 0;
	iface_num = face_num;
	irow = 0;
	ix = 0;
	ixyz = 0;
	iy = 0;
	iz = 0;
	jval = 0;
	level = 0;
	llevel[0]=NameItm();
	strcpy ( llevel[0].name, "Top" );
	nlbrack = 0;
	nrbrack = 0;
	nu = 0;
	vertex_num_old = vertex_num;
	face_num2 = face_num;
	shape_num2 = shape_num;
	normal_num_temp = 0;
	text_numure_temp = 0;
	nv = 0;
	rval = 0.0;



	char  word[LINE_MAX_LEN];
	strcpy ( word, " " );

	// Read the next line of text from the input file.
    for ( ;; )
    {
      char input[LINE_MAX_LEN];
      if ( fgets ( input, LINE_MAX_LEN, filein ) == NULL )
          break;
      stats.text_num++;
      char *next = input;
      { // Remove all commas from the line, so we can use SSCANF to read
        // numeric items.
        unsigned long i = 0;
        while ( (input[i]!='\0')&&(i<LINE_MAX_LEN) )
        {
			if ( input[i] == ',' )
				input[i] = ' ';
			++i;
        }
      }
      {// Force brackets and braces to be buffered by spaces
        unsigned int null_index;
        unsigned int i = 0;
        while ( (input[i]!='\0')&&(i<LINE_MAX_LEN) )
			++i;
		null_index = i;
        i = 0;
		while ( (input[i]!='\0') && (i<LINE_MAX_LEN) )
        {
			if ( (input[i]=='[') || (input[i]==']') ||
				 (input[i]=='{') || (input[i]=='}') )
            {
                result = char_pad( &i, &null_index, input, LINE_MAX_LEN );
                if ( result == false ) break;
            } else
            {
				++i;
			}
		}
      }
      // Read a word from the line.
      unsigned long iword = 0;
      char word1[LINE_MAX_LEN];
      for ( ;; )
      {
          char  wordm1[LINE_MAX_LEN];
          strcpy ( wordm1, word );
          strcpy ( word, " " );

          int width=0;
          unsigned long count = sscanf ( next, "%s%n", word, &width );
          next+=width;

          if ( count != 1 ) break;
          iword++;
          if (iword==1) strcpy( word1, word );

          // The first line of the file must be the header.
          if ( stats.text_num == 1 )
          {
              if ( !leqi( word1, "#Inventor" ) && !leqi( word1, "#VRML" ))
              {
                  printf ( "\n" );
                  printf ( "IV_READ - Fatal error!\n" );
                  printf ( "  The input file has a bad header.\n" );
                  return false;
              } else
              {
                  stats.comment_num ++;
              }
              break;
          }

          // A comment begins anywhere with '#'.
          // Skip the rest of the line.
          if ( word[1] == '#' )
          {
              stats.comment_num++;
              break;
          }

          // If the word is a curly or square bracket, count it.
          // If the word is a left bracket, the previous word is the name of a node.
          if ( (strcmp(word,"{")==0) || (strcmp(word,"[")==0) )
          {
				nlbrack = nlbrack + 1;
				level = nlbrack - nrbrack;
				strcpy ( llevel[level].name, wordm1 );
				if ( debug )
					printf ( "IV_READ: Begin level: \"%s\" on line %lu\n",wordm1,stats.text_num );
          } else
          if ( (strcmp(word,"}")==0) || (strcmp(word,"]")==0) )
          {
				nrbrack = nrbrack + 1;
				if ( nlbrack < nrbrack )
                {
					printf ( "\n" );
					printf ( "IV_READ - Fatal error!\n" );
					printf ( "  Extraneous right bracket on line %d.\n", stats.text_num );
					printf ( "  Currently processing field \"%s\"\n.", llevel[level].name );
					return false;
				}
          }

          // BASECOLOR
          if ( leqi ( llevel[level].name, "BASECOLOR" )  )
          {
				if ( strcmp(word,"{") == 0 )
                {
				} else
				if ( strcmp(word,"}") == 0 )
                {
					level = nlbrack - nrbrack;
				} else
				if ( leqi ( word, "RGB" )  )
                {
				} else
				{
					stats.bad_num++;
					printf ( "IV_READ: Bad data \"%s\" on line %lu\n", word,stats.text_num );
				}
          } else

			// COORDINATE3
			if ( leqi( llevel[level].name, "COORDINATE3" )  )
            {
				if ( strcmp( word, "{" ) == 0 )
                {
				} else
				if ( strcmp( word, "}" ) == 0 )
                {
					level = nlbrack - nrbrack;
				} else
				if ( leqi ( word, "POINT" )  )
                {
				} else
				{
					stats.bad_num++;
					printf ( "COORDINATE3: Bad data %s\n", word );
				}
			} else

			// COORDINATE4
			if ( leqi ( llevel[level].name, "COORDINATE4" )  ) {

				if ( strcmp ( word, "{" ) == 0 ) {
				}
				else if ( strcmp ( word, "}" ) == 0 ) {
					level = nlbrack - nrbrack;
				}
				else if ( leqi ( word, "POINT" )  ) {
				}
				else {
					stats.bad_num++;
					printf ( "COORDINATE4: Bad data %s\n", word );
				}
			}
			/*
			COORDINDEX
			*/
			else if ( leqi ( llevel[level].name, "COORDINDEX" )  ) {

				if ( strcmp ( word, "[" ) == 0 ) {
					ivert = 0;
				}
				else if ( strcmp ( word, "]" ) == 0 ) {
					level = nlbrack - nrbrack;
				}
				/*
				(indexedlineset) COORDINDEX
				*/
				else if ( leqi ( llevel[level-1].name, "INDEXEDLINESET" )  ) {

					count = sscanf ( word, "%d%n", &jval, &width );

					if ( count > 0 ) {

						if ( jval < -1 ) {
							stats.bad_num++;
						}
						else {
							//if ( shape_num < LINES_MAX )
                            {
								if ( jval != -1 ) {
									jval = jval + vertex_num_old;
								}
//!!!!								line_dex[shape_num] = jval;
							}
							++shape_num;
						}
					}
					else {
						stats.bad_num++;
					}
				}
				/*
				(indexedfaceset) COORDINDEX
				Warning: If the list of indices is not terminated with a final -1, then
				the last face won't get counted.
				*/
				else if ( leqi ( llevel[level-1].name, "INDEXEDFACESET" )  ) {

					count = sscanf ( word, "%d%n", &jval, &width );

					if ( count > 0 )
                    {
						if ( jval == -1 )
                        {
							ivert = 0;
							++face_num;
						}
						else {
							if ( ivert == 0 ) {
								// if ( face_num < FACE_MAX )
								{
									face[face_num].order = 0;
								}
							}
							// if ( face_num < FACE_MAX )
							{
								face[face_num].order = face[face_num].order + 1;
								face[face_num].vertices[ivert] = jval + vertex_num_old;
								ivert = ivert + 1;
							}
						}
					}
				}
				/*
				(indexednurbssurface) COORDINDEX
				*/
				else if ( leqi ( llevel[level-1].name, "INDEXEDNURBSSURFACE" )  ) {
				}
				/*
				(indexedtrianglestripset) COORDINDEX

				  First three coordinate indices I1, I2, I3 define a triangle.
				  Next triangle is defined by I2, I3, I4 (actually, I4, I3, I2
				  to stay with same counterclockwise sense).
				  Next triangle is defined by I3, I4, I5 ( do not need to reverse
				  odd numbered triangles) and so on.
				  List is terminated with -1.
				*/
				else if ( leqi ( llevel[level-1].name, "INDEXEDTRIANGLESTRIPSET" )  ) {

					count = sscanf ( word, "%d%n", &jval, &width );

					if ( count > 0 ) {

						if ( jval == -1 ) {
							ivert = 0;
						}
						else {

							ix = iy;
							iy = iz;
							iz = jval + vertex_num_old;

							if ( ivert == 0 ) {
								// if ( face_num < FACE_MAX )
								{
									face[face_num].vertices[ivert] = jval + vertex_num_old;
									face[face_num].order = 3;
								}
							}
							else if ( ivert == 1 ) {
								// if ( face_num < FACE_MAX )
								{
									face[face_num].vertices[ivert] = jval + vertex_num_old;
								}
							}
							else if ( ivert == 2 ) {
								// if ( face_num < FACE_MAX )
								{
									face[face_num].vertices[ivert] = jval + vertex_num_old;
								}
								++face_num;
							}
							else {

								// if ( face_num < FACE_MAX )
								{
									face[face_num].order = 3;
									if ( ( ivert % 2 ) == 0 ) {
										face[face_num].vertices[0] = ix;
										face[face_num].vertices[1] = iy;
										face[face_num].vertices[2] = iz;
									}
									else {
										face[face_num].vertices[0] = iz;
										face[face_num].vertices[1] = iy;
										face[face_num].vertices[2] = ix;
									}
								}
								++face_num;
							}
							ivert = ivert + 1;
							/*
							Very very tentative guess as to how indices into the normal
							vector array are set up...
							*/
							if (ivert > 2 ) {	//  face_num < FACE_MAX &&
								for ( i = 0; i < 3; ++i ) {
									face[face_num].normal[i] = normal_temp[ix][i];
								}
							}
						}
					}
				}
      }
	  /*
	  INDEXEDFACESET
	  */
      else if ( leqi ( llevel[level].name, "INDEXEDFACESET" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "COORDINDEX" )  ) {
			  ivert = 0;
		  }
		  else if ( leqi ( word, "MATERIALINDEX" )  ) {
		  }
		  else if ( leqi ( word, "NORMALINDEX" )  ) {
		  }
		  else if ( leqi ( word, "TEXTURECOORDINDEX" )  ) {
			  if ( texture_num <= 0 ) {
				  texture_num = 1;
				  strcpy ( texture[0].name, "Texture_0000" );
			  }
		  }
		  else {
			  stats.bad_num++;
			  printf ( "Bad data %s\n", word );
		  }
      }
	  /*
	  INDEXEDLINESET
	  */
      else if ( leqi ( llevel[level].name, "INDEXEDLINESET" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "COORDINDEX" )  ) {
		  }
		  else if ( leqi ( word, "MATERIALINDEX" )  ) {
		  }
		  else {
			  stats.bad_num++;
			  printf ( "Bad data %s\n", word );
		  }
      }
	  /*
	  INDEXEDNURBSSURFACE
	  */
      else if ( leqi ( llevel[level].name, "INDEXEDNURBSSURFACE" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "NUMUCONTROLPOINTS")  ) {

			  count = sscanf ( word, "%d%n", &jval, &width );

			  if ( count > 0 ) {
				  nu = jval;
				  if ( debug ) {
					  printf ( "NU = %d\n", nu );
				  }
			  }
			  else {
				  nu = 0;
				  stats.bad_num++;
				  printf ( "Bad data %s\n", word );
			  }
		  }
		  else if ( leqi ( word, "NUMVCONTROLPOINTS" )  ) {

			  count = sscanf ( word, "%d%n", &jval, &width );

			  if ( count > 0 ) {
				  nv = jval;
				  if ( debug ) {
					  printf ( "NV = %d\n", nv );
				  }
			  }
			  else {
				  nv = 0;
				  stats.bad_num++;
			  }
		  }
		  else if ( leqi ( word, "COORDINDEX" )  ) {
		  }
		  else if ( leqi ( word, "UKNOTVECTOR" )  ) {
		  }
		  else if ( leqi ( word, "VKNOTVECTOR" )  ) {
		  }
		  else {
			  stats.bad_num++;
			  printf ( "Bad data %s\n", word );
		  }
      }
	  /*
	  INDEXEDTRIANGLESTRIPSET
	  */
      else if ( leqi ( llevel[level].name, "INDEXEDTRIANGLESTRIPSET" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "VERTEXPROPERTY" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else if ( leqi ( word, "COORDINDEX" )  ) {
			  ivert = 0;
		  }
		  else if ( leqi ( word, "NORMALINDEX" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else {
			  stats.bad_num++;
			  printf ( "Bad data %s\n", word );
		  }
      }
	  /*
	  INFO
	  */
      else if ( leqi ( llevel[level].name, "INFO" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "STRING" )  ) {
		  }
		  else if ( strcmp ( word, "\"" ) == 0 ) {
		  }
		  else {
		  }
      }
	  /*
	  LIGHTMODEL
	  Read, but ignore.
	  */
      else if ( leqi ( llevel[level].name, "LIGHTMODEL" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "model" )  ) {
		  }
		  else {
		  }
      }
	  /*
	  MATERIAL
	  Read, but ignore.
	  */
      else if ( leqi ( llevel[level].name,"MATERIAL" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "AMBIENTCOLOR" )  ) {
		  }
		  else if ( leqi ( word, "EMISSIVECOLOR" )  ) {
		  }
		  else if ( leqi ( word, "DIFFUSECOLOR" )  ) {
		  }
		  else if ( leqi ( word, "SHININESS" )  ) {
		  }
		  else if ( leqi ( word, "SPECULARCOLOR" )  ) {
		  }
		  else if ( leqi ( word, "TRANSPARENCY" )  ) {
		  }
		  else {
		  }
      }
	  /*
	  MATERIALBINDING
	  Read, but ignore
	  */
      else if ( leqi ( llevel[level].name, "MATERIALBINDING" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "VALUE" )  ) {
			  count = sscanf ( next, "%s%n", material_binding, &width );
			  next = next + width;
		  }
		  else {
			  count = sscanf ( next, "%f%n", &rval, &width );
			  next = next + width;

			  if ( count > 0 ) {
			  }
			  else {
				  stats.bad_num++;
				  printf ( "Bad data %s\n", word );
			  }
		  }
      }
	  /*
	  MATERIALINDEX
	  */
      else if ( leqi ( llevel[level].name, "MATERIALINDEX" )  ) {

		  if ( strcmp ( word, "[" ) == 0 ) {
			  ivert = 0;
		  }
		  else if ( strcmp ( word, "]" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  /*
		  (indexedfaceset) MATERIALINDEX
		  */
		  else if ( leqi ( llevel[level-1].name, "INDEXEDFACESET" )  ) {

			  count = sscanf ( word, "%d%n", &jval, &width );

			  if ( count > 0 ) {

				  if ( jval == -1 ) {
					  ivert = 0;
					  face_num2 = face_num2 + 1;
				  }
				  else {

					  // if ( face_num2 < FACE_MAX )
					  {
						  if ( jval != -1 ) {
							  jval = jval + vertex_num_old;
						  }
						  unsigned long vertidx = face[face_num2].vertices[ivert];
						  vertex[vertidx].material = jval;
						  ivert = ivert + 1;
					  }
				  }
			  }
			  else {
				  stats.bad_num++;
				  printf ( "Bad data %s\n", word );
			  }
		  }
		  /*
		  (indexedlineset) MATERIALINDEX
		  */
		  else if ( leqi ( llevel[level-1].name, "INDEXEDLINESET" )  ) {

			  count = sscanf ( word, "%d%n", &jval, &width );

			  if ( count > 0 ) {

				  //if ( shape_num2 < LINES_MAX )
                  {
					  if ( jval != -1 ) {
						  jval = jval + vertex_num_old;
					  }
//!!!					  line_material[shape_num2] = jval;
					  shape_num2 = shape_num2 + 1;
				  }
			  }
			  else {
				  stats.bad_num++;
				  printf ( "Bad data %s\n", word );
			  }
		  }
		  else {
			  count = sscanf ( word, "%d%n", &jval, &width );

			  if ( count > 0 ) {
			  }
			  else {
				  stats.bad_num++;
				  printf ( "Bad data %s\n", word );
			  }
		  }
      }
	  /*
	  MATRIXTRANSFORM.
	  */
      else if ( leqi ( llevel[level].name, "MATRIXTRANSFORM" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "MATRIX" )  ) {
			  icol = -1;
			  irow = 0;
		  }
		  else {

			  count = sscanf ( word, "%f%n", &rval, &width );

			  if ( count > 0 ) {

				  icol = icol + 1;
				  if ( icol > 3 ) {
					  icol = 0;
					  irow = irow + 1;
					  if ( irow > 3 ) {
						  irow = 0;
					  }
				  }

				  transform_matrix[irow][icol] = rval;
			  }

		  }
      }
	  /*
	  NORMAL
	  The field "VECTOR" may be followed by three numbers,
	  (handled here),  or by a square bracket, and sets of three numbers.
	  */
      else if ( leqi ( llevel[level].name, "NORMAL" )  ) {
	  /*
	  (vertexproperty) NORMAL
		  */
		  if ( leqi ( llevel[level-1].name, "VERTEXPROPERTY" )  ) {

			  if ( strcmp ( word, "[" ) == 0 ) {
				  ixyz = 0;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {

				  count = sscanf ( word, "%f%n", &rval, &width );

				  if ( count > 0 ) {

					  // if ( inormface < FACE_MAX )
					  {
						  face[inormface].normal[ixyz] = rval;
					  }

					  ixyz = ixyz + 1;
					  if ( ixyz > 2 ) {
						  ixyz = 0;
						  inormface = inormface + 1;
					  }
				  }
			  }
		  }
		  /*
		  (anythingelse) NORMAL
		  */
		  else {

			  if ( strcmp ( word, "{" ) == 0 ) {
				  ixyz = 0;
			  }
			  else if ( strcmp ( word, "}" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else if ( leqi ( word, "VECTOR" )  ) {
			  }
			  else {

				  count = sscanf ( word, "%f%n", &rval, &width );

				  if ( count > 0 ) {

				  /*  COMMENTED OUT

					if ( nfnorm < FACE_MAX ) {
					normal[ixyz][nfnorm] = rval;
					}

					  */
					  ixyz = ixyz + 1;
					  if ( ixyz > 2 ) {
						  ixyz = 0;
					  }
				  }
				  else {
					  stats.bad_num++;
					  printf ( "Bad data %s\n", word );
				  }
			  }
		  }
      }
	  /*
	  NORMALBINDING
	  Read, but ignore
	  */
      else if ( leqi ( llevel[level].name, "NORMALBINDING" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "VALUE" )  ) {
               char normal_binding[LINE_MAX_LEN];
			  count = sscanf ( next, "%s%n", normal_binding, &width );
			  next = next + width;
		  }
		  else {
			  count = sscanf ( word, "%f%n", &rval, &width );

			  if ( count > 0 ) {
			  }
			  else {
				  stats.bad_num++;
				  printf ( "Bad data %s\n", word );
			  }
		  }
      }
	  /*
	  NORMALINDEX
	  */
      else if ( leqi ( llevel[level].name, "NORMALINDEX" )  ) {
	  /*
	  (indexedtrianglestripset) NORMALINDEX
		  */
		  if ( leqi ( llevel[level-1].name, "INDEXEDTRIANGLESTRIPSET" )  ) {
			  count = sscanf ( word, "%d%n", &jval, &width );

			  if ( count > 0 ) {
			  }
			  else if ( strcmp ( word, "[" ) == 0 ) {
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
			  }
		  }
		  /*
		  (anythingelse) NORMALINDEX
		  */
		  else {

			  if ( strcmp ( word, "[" ) == 0 ) {
				  ivert = 0;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {

				  count = sscanf ( word, "%d%n", &jval, &width );

				  if ( count > 0 ) {
					  if ( jval == -1 ) {
						  ivert = 0;
						  iface_num = iface_num + 1;
					  }
					  else {
						  // if ( iface_num < FACE_MAX )
						  {
                                unsigned long vertidx = face[iface_num].vertices[ivert];
								vertex[vertidx].normal = normal_temp[jval];
							  ivert = ivert + 1;
						  }
					  }
				  }
				  else {
					  stats.bad_num++;
					  printf ( "Bad data %s\n", word );
				  }
			  }
		  }
      }
	  /*
	  (coordinate3) POINT
	  */
      else if ( leqi ( llevel[level].name, "POINT" )  ) {

		  if ( leqi ( llevel[level-1].name, "COORDINATE3" )  ) {

			  if ( strcmp ( word, "[" ) == 0 ) {
				  ixyz = 0;
				  vertex_num_old = vertex_num;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {

				  count = sscanf ( word, "%f%n", &rval, &width );

				  if ( count > 0 ) {

//					  if ( vertex_num < COR3_MAX )
					  {
						  xvec[ixyz] = rval;
					  }

					  ixyz = ixyz + 1;

					  if ( ixyz == 3 ) {

						  ixyz = 0;

						  tmat_mxp ( transform_matrix, xvec, xvec );

						  vertex[vertex_num].cor3[0] = xvec[0];
						  vertex[vertex_num].cor3[1] = xvec[1];
						  vertex[vertex_num].cor3[2] = xvec[2];

						  vertex_num ++;

						  continue;
					  }
				  }
				  else {
					  stats.bad_num++;
					  break;
				  }
			  }
		  }
		  /*
		  (texturecoodinate2) POINT
		  */
		  else if ( leqi ( llevel[level-1].name, "TEXTURECOORDINATE2" )  ) {

			  if ( strcmp ( word, "[" ) == 0 ) {
				  iuv = 0;
				  text_numure_temp = 0;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {

				  count = sscanf ( word, "%f%n", &rval, &width );

				  if ( count > 0 ) {

					  texture_temp[text_numure_temp][iuv] = rval;

					  iuv = iuv + 1;
					  if ( iuv == 2 ) {
						  iuv = 0;
						  text_numure_temp = text_numure_temp + 1;
					  }
				  }
				  else {
					  printf ( "TextureCoordinate2 { Point [: Bad data\n" );
					  stats.bad_num++;
					  break;
				  }
			  }
		  }
      }
	  /*
	  RGB
	  */
      else if ( leqi ( llevel[level].name,"RGB" )  ) {
	  /*
	  (basecolor) RGB
		  */
		  if ( leqi ( llevel[level-1].name, "BASECOLOR" )  ) {

			  if ( strcmp ( word, "[" ) == 0 ) {
				  icolor = 0;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {

				  count = sscanf ( word, "%f%n", &rval, &width );

				  if ( count > 0 ) {

					  rgbcolor[color_num][icolor] = rval;
					  icolor = icolor + 1;

					  if ( icolor == 3 ) {
						  icolor = 0;
						  color_num = color_num + 1;
					  }
				  }
				  else {
					  stats.bad_num++;
					  printf ( "Bad data %s\n", word );
				  }
			  }
		  }
		  /*
		  (anythingelse RGB)
		  */
		  else {

			  printf ( "HALSBAND DES TODES!\n" );

			  if ( strcmp ( word, "[" ) == 0 ) {
				  icolor = 0;
				  ivert = 0;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {

				  count = sscanf ( word, "%f%n", &rval, &width );

				  if ( count > 0 ) {

					  // if ( icface < FACE_MAX )
					  {
						  unsigned long vertidx=face[icface].vertices[ivert];
						  vertex[vertidx].rgb[icolor] = rval;

						  icolor = icolor + 1;
						  if ( icolor == 3 ) {
							  icolor = 0;
							  color_num = color_num + 1;
							  ivert = ivert + 1;
							  if ( ivert == face[icface].order ) {
								  ivert = 0;
								  icface = icface + 1;
							  }
						  }
					  }
				  }
				  else {
					  stats.bad_num++;
					  printf ( "Bad data %s\n", word );
				  }
			  }
		  }

      }
	  /*
	  SEPARATOR
	  */
      else if ( leqi ( llevel[level].name, "SEPARATOR" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else {
		  }
      }
	  /*
	  SHAPEHINTS
	  Read, but ignore.
	  */
      else if ( leqi ( llevel[level].name, "SHAPEHINTS" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "CREASEANGLE" )  ) {

			  count = sscanf ( next, "%f%n", &rval, &width );
			  next = next + width;

			  if ( count <= 0 ) {
				  stats.bad_num++;
				  printf ( "Bad data %s\n", word );
			  }
		  }
		  else if ( leqi ( word, "FACETYPE" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else if ( leqi ( word, "SHAPETYPE" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else if ( leqi ( word, "VERTEXORDERING" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else {
			  stats.bad_num++;
			  printf ( "Bad data %s\n", word );
		  }
      }
	  /*
	  TEXTURE2
	  */
      else if ( leqi ( llevel[level].name, "TEXTURE2" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
			  texture_num = texture_num + 1;
		  }
		  else if ( leqi ( word, "BLENDCOLOR" )  ) {
		  }
		  /*
		  NEED TO REMOVE QUOTES SURROUNDING TEXTURE NAME.
		  */
		  else if ( leqi ( word, "FILENAME" )  ) {

			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;

			  strcpy ( ttexture[texture_num].name, word );

			  i = 0;
			  j = 0;
			  do {
				  c = ttexture[texture_num].name[i];
				  i = i + 1;
				  if ( c != '"' ) {
					  ttexture[texture_num].name[j] = c;
					  j = j + 1;
				  }
			  } while ( c != '\0' );

		  }
		  else if ( leqi ( word, "IMAGE" )  ) {
		  }
		  else if ( leqi ( word, "MODEL" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else if ( leqi ( word, "WRAPS" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else if ( leqi ( word, "WRAPT" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else {
		  }
      }
	  /*
	  TEXTURECOORDINATE2
	  */
      else if ( leqi ( llevel[level].name, "TEXTURECOORDINATE2" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "POINT" )  ) {
		  }
		  else {
			  stats.bad_num++;
			  printf ( "TEXTURECOORDINATE2: Bad data %s\n", word );
		  }
      }
	  /*
	  TEXTURECOORDINATEBINDING
	  */
      else if ( leqi ( llevel[level].name, "TEXTURECOORDINATEBINDING" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "VALUE" )  ) {
			  count = sscanf ( next, "%s%n", texture_binding, &width );
			  next = next + width;
		  }
		  else {
			  stats.bad_num++;
			  printf ( "Bad data %s\n", word );
		  }
      }
	  /*
	  TEXTURECOORDINDEX
	  */
      else if ( leqi ( llevel[level].name, "TEXTURECOORDINDEX" )  ) {

		  if ( strcmp ( word, "[" ) == 0 ) {
			  ivert = 0;
			  iface_num = 0;
		  }
		  else if ( strcmp ( word, "]" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else {

			  count = sscanf ( word, "%d%n", &jval, &width );

			  if ( count > 0 ) {

				  if ( jval == - 1 ) {
					  ivert = 0;
				  }
				  else {

                          unsigned int vertidx=face[iface_num].vertices[ivert];
						  vertex[vertidx].tex_uv = texture_temp[jval];

					  ivert = ivert + 1;

					  if ( ivert == face[iface_num].order ) {
						  ivert = 0;
						  iface_num = iface_num + 1;
					  }
				  }

			  }
			  else {
				  stats.bad_num++;
				  printf ( "Bad data %s\n", word );
			  }

		  }
      }
	  /*
	  UKNOTVECTOR
	  */
      else if ( leqi ( llevel[level].name, "UKNOTVECTOR" )  ) {

		  if ( strcmp ( word, "[" ) == 0 ) {
			  continue;
		  }
		  else if ( strcmp ( word, "]" ) == 0 ) {
			  level = nlbrack - nrbrack;
			  continue;
		  }
		  else {
			  count = sscanf ( word, "%d%n", &jval, &width );
		  }
      }
	  /*
	  VECTOR
	  */
      else if ( leqi ( llevel[level].name, "VECTOR" )  ) {
		  if ( strcmp ( word, "[" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "]" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  /*
		  (normal) VECTOR
		  */
		  else if ( leqi ( llevel[level-1].name, "NORMAL" )  ) {

			  count = sscanf ( word, "%f%n", &rval, &width );

			  if ( count > 0 ) {

				  // if ( normal_num_temp < ORDER_MAX * FACE_MAX )
				  {
					  normal_temp[normal_num_temp][ixyz] = rval;
					  ixyz = ixyz + 1;
					  if ( ixyz == 3 ) {
						  ixyz = 0;
						  normal_num_temp = normal_num_temp + 1;
					  }
				  }
			  }
			  else {
				  stats.bad_num++;
				  printf ( "NORMAL VECTOR: bad data %s\n", word );
			  }
		  }
      }
	  /*
	  (vertexproperty) VERTEX
	  */
      else if ( leqi ( llevel[level].name, "VERTEX" )  ) {

		  if ( leqi ( llevel[level-1].name, "VERTEXPROPERTY" )  ) {

			  if ( strcmp ( word, "[" ) == 0 ) {
				  ixyz = 0;
				  vertex_num_old = vertex_num;
			  }
			  else if ( strcmp ( word, "]" ) == 0 ) {
				  level = nlbrack - nrbrack;
			  }
			  else {
				  count = sscanf ( word, "%f%n", &rval, &width );

				  if ( count > 0 ) {

//					  if ( vertex_num < COR3_MAX )
					  {
						  vertex[vertex_num].cor3[ixyz] = rval;
					  }
					  ixyz = ixyz + 1;
					  if ( ixyz == 3 ) {
						  ixyz = 0;
						  vertex_num = vertex_num + 1;
					  }

				  }
				  else {
					  stats.bad_num++;
					  printf ( "Bad data %s\n", word );
				  }
			  }
		  }
      }
	  /*
	  (indexedtrianglestripset) VERTEXPROPERTY
	  */
      else if ( leqi ( llevel[level].name, "VERTEXPROPERTY" )  ) {

		  if ( strcmp ( word, "{" ) == 0 ) {
		  }
		  else if ( strcmp ( word, "}" ) == 0 ) {
			  level = nlbrack - nrbrack;
		  }
		  else if ( leqi ( word, "VERTEX" )  ) {
		  }
		  else if ( leqi ( word, "NORMAL" )  ) {
			  ixyz = 0;
		  }
		  else if ( leqi ( word, "MATERIALBINDING" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else if ( leqi ( word, "NORMALBINDING" )  ) {
			  count = sscanf ( next, "%s%n", word, &width );
			  next = next + width;
		  }
		  else {
			  stats.bad_num++;
			  printf ( "Bad data %s\n", word );
		  }
      } else

	  // VKNOTVECTOR
      if ( leqi ( llevel[level].name, "VKNOTVECTOR" )  )
      {
		  if ( strcmp ( word, "[" ) == 0 )
          {
			  continue;
		  } else
		  if ( strcmp ( word, "]" ) == 0 )
          {
			  level = nlbrack - nrbrack;
			  continue;
		  } else
		  {
			  count = sscanf ( word, "%d%n", &jval, &width );
		  }
      } else

	  // Any other word:
      {
      }
    }
    }// end for ( ;; )

  // Reset the transformation matrix to the identity,
  // because, presumably, we've applied it by now.
  tmat_init ( transform_matrix );

  return true;
}
/******************************************************************************/

bool IVCONV::iv_write_basecolor ( FILE *fileout,array<vec3> rgbcolor,unsigned long color_num )

/******************************************************************************/
/*
Purpose:
  IV_WRITE_BASECOLOR writes color list to an Inventor file.

    Author: John Burkardt
    Modified: 29 June 1999
	Modified: 08 Mar 2007 Tomasz Lis created as new function
*/
{
		fprintf ( fileout, "    BaseColor {\n" );
		fprintf ( fileout, "      rgb [\n" );
        stats.text_num += 2;
        unsigned long j;
		for ( j = 0; j < color_num; ++j )
        {
			fprintf ( fileout, "        %f %f %f,\n", rgbcolor[0][j], rgbcolor[1][j],
				rgbcolor[2][j] );
			stats.text_num++;
		}
		fprintf ( fileout, "      ]\n" );
		fprintf ( fileout, "    }\n" );
        stats.text_num += 2;
	if (debug)
      printf ( "  IV_WRITE_BASECOLOR: BaseColor ends at line %lu\n", stats.text_num );
	return true;
}
/******************************************************************************/

bool IVCONV::iv_write_lineset ( FILE *fileout )

/******************************************************************************/
/*
Purpose:
  IV_WRITE_LINESET writes line set to an Inventor file.

    Author: John Burkardt
    Modified: 29 June 1999
	Modified: 08 Mar 2007 Tomasz Lis created as new function
*/
{
		fprintf ( fileout, "    IndexedLineSet {\n" );
        stats.text_num++;

		// IndexedLineSet coordIndex
		fprintf ( fileout, "      coordIndex [\n" );
        stats.text_num++;
		unsigned long shapeidx;
        for ( shapeidx = 0; shapeidx < shape_num; shapeidx++ )
        {
            fprintf ( fileout, "       " );
            unsigned long order=shape[shapeidx].order;
            if (order>10)
            {
                if (debug)
                  printf ( "  IV_WRITE_LINESET: Shape %lu to long, truncated at line %lu\n",shapeidx,stats.text_num );
                order=10;
            }
            unsigned long ivert;
/*            for ( ivert = 0; ivert < shape_vert_num; ivert++ )
            {
                fprintf ( fileout, " %d,", line_dex[ivert] );
            }
*/
            fprintf ( fileout, "%d\n",-1 );
            stats.text_num++;
		}
		fprintf ( fileout, "      ]\n" );
		stats.text_num++;

		// IndexedLineSet materialIndex.
		fprintf ( fileout, "      materialIndex [\n" );
		stats.text_num++;

		unsigned long length = 0;
		unsigned long j;
		for ( j = 0; j < shape_num; ++j )
        {
			if ( length == 0 )
				fprintf ( fileout, "       " );
//			fprintf ( fileout, " %d,", line_material[j] );
			length = length + 1;
/*
			if ( line_material[j] == -1 || length >= 10 || j == shape_num-1 )
            {
				fprintf ( fileout, "\n" );
				stats.text_num++;
				length = 0;
			}*/
		}
		fprintf ( fileout, "      ]\n" );
		fprintf ( fileout, "    }\n" );
        stats.text_num += 2;
	if (debug)
      printf ( "  IV_WRITE_LINESET: Line set ends at line %lu\n", stats.text_num );
	return true;
}
/******************************************************************************/

bool IVCONV::iv_write_faceset ( FILE *fileout )

/******************************************************************************/
/*
Purpose:
  IV_WRITE_FACESET writes face set to an Inventor file.

    Author: John Burkardt
    Modified: 29 June 1999
	Modified: 08 Mar 2007 Tomasz Lis created as new function
*/
{
		fprintf ( fileout, "    IndexedFaceSet {\n" );
		fprintf ( fileout, "      coordIndex [\n" );
		stats.text_num += 2;
        unsigned long iface;
		for ( iface = 0; iface < face_num; iface++ )
        {
			fprintf ( fileout, "       " );
            unsigned long ivert;
			for ( ivert = 0; ivert < face[iface].order; ivert++ )
            {
                unsigned long vertidx=face[iface].vertices[ivert];
				fprintf ( fileout, " %d,", vertidx );
			}
			fprintf ( fileout, " -1,\n" );
			stats.text_num++;
		}
		fprintf ( fileout, "      ]\n" );
		stats.text_num++;

		// IndexedFaceSet normalIndex
		fprintf ( fileout, "      normalIndex [\n" );
		stats.text_num++;
		for ( iface = 0; iface < face_num; iface++ )
        {
            unsigned long ivert;
			fprintf ( fileout, "       " );
			for ( ivert = 0; ivert < face[iface].order; ivert++ )
            {
                unsigned long vertidx=face[iface].vertices[ivert];
				fprintf ( fileout, " %lu,", vertidx );
			}
			fprintf ( fileout, " -1,\n" );
			stats.text_num++;
		}
		fprintf ( fileout, "      ]\n" );
		stats.text_num++;

		// IndexedFaceSet materialIndex
		fprintf ( fileout, "      materialIndex [\n" );
		stats.text_num++;
		for ( iface = 0; iface < face_num; iface++ )
        {
            unsigned long ivert;
			fprintf ( fileout, "       " );
			for ( ivert = 0; ivert < face[iface].order; ivert++ )
            {
                unsigned long vertidx=face[iface].vertices[ivert];
				fprintf ( fileout, " %d,", vertex[vertidx].material );
			}
			fprintf ( fileout, " -1,\n" );
			stats.text_num++;
		}
		fprintf ( fileout, "      ]\n" );
		stats.text_num++;

		// IndexedFaceSet textureCoordIndex
		fprintf ( fileout, "      textureCoordIndex [\n" );
		stats.text_num++;
		unsigned long itemp = 0;
		for ( iface = 0; iface < face_num; iface++ )
        {
            unsigned long ivert;
			fprintf ( fileout, "       " );
			for ( ivert = 0; ivert < face[iface].order; ivert++ )
            {
				fprintf ( fileout, " %d,", itemp );
				itemp++;
			}
			fprintf ( fileout, " -1,\n" );
			stats.text_num++;
		}
		fprintf ( fileout, "      ]\n" );
        stats.text_num++;

		fprintf ( fileout, "    }\n" );
        stats.text_num++;
	if (debug)
      printf ( "  IV_WRITE_FACESET: Face set ends at line %lu\n", stats.text_num );
	return true;
}
/******************************************************************************/

bool IVCONV::iv_write_vertnormals ( FILE *fileout )

/******************************************************************************/
/*
Purpose:
  IV_WRITE_VERTNORMALS writes vertices normal vectors to an Inventor file.

    Author: John Burkardt
    Modified: 29 June 1999
	Modified: 08 Mar 2007 Tomasz Lis created as new function
*/
{
		fprintf ( fileout, "    Normal { \n" );
		fprintf ( fileout, "      vector [\n" );
        stats.text_num += 2;
	    unsigned long icor3;
		for ( icor3 = 0; icor3 < vertex_num; icor3++ )
        {
			fprintf ( fileout, "        %f %f %f,\n",
				vertex[icor3].normal[0],
				vertex[icor3].normal[1],
				vertex[icor3].normal[2] );
			stats.text_num++;
		}

		fprintf ( fileout, "      ]\n" );
		fprintf ( fileout, "    }\n" );
		stats.text_num += 2;
	if (debug)
      printf ( "  IV_WRITE_VERTNORMALS: Vertex normal vectors ends at line %lu\n", stats.text_num );
	return true;
}
/******************************************************************************/

bool IVCONV::iv_write_texture ( FILE *fileout, long textr_idx )

/******************************************************************************/
/*
Purpose:
  IV_WRITE_TEXTURE writes texture section to an Inventor file.

    Author: John Burkardt
    Modified: 29 June 1999
	Modified: 08 Mar 2007 Tomasz Lis created as new function
*/
{
		fprintf ( fileout, "    Texture2 {\n" );
		fprintf ( fileout, "      filename \"%s\"\n", texture[textr_idx].name );
		fprintf ( fileout, "      wrapS       %s\n","REPEAT" );
		fprintf ( fileout, "      wrapT       %s\n","REPEAT" );
		fprintf ( fileout, "      model       %s\n","MODULATE" );
		fprintf ( fileout, "      blendColor  %f %f %f\n",0.0,0.0,0.0 );
		fprintf ( fileout, "    }\n" );
		stats.text_num += 7;
	if (debug)
      printf ( "  IV_WRITE_TEXTURE: Texture ends at line %lu\n", stats.text_num );
    return true;
}
/******************************************************************************/

bool IVCONV::iv_write_lmodel_and_matbind ( FILE *fileout )

/******************************************************************************/
/*
Purpose:
  IV_WRITE_LMODEL_AND_MATBIND writes some short sections to an Inventor file.

    Author: John Burkardt
    Modified: 29 June 1999
	Modified: 08 Mar 2007 Tomasz Lis created as new function
*/
{
  //LightModel:
  //  BASE_COLOR ignores light sources, and uses only diffuse color
  //    and transparency.  Even without normal vector information,
  //    the object will show up.  However, you won't get shadow
  //    and lighting effects.
  //  PHONG uses the Phong lighting model, accounting for light sources
  //    and surface orientation.  This is the default.  I believe
  //    you need accurate normal vector information in order for this
  //    option to produce nice pictures.
  //  DEPTH ignores light sources, and calculates lighting based on
  //    the location of the object within the near and far planes
  //    of the current camera's view volume.
	fprintf ( fileout, "    LightModel {\n" );
	fprintf ( fileout, "      model %s\n","PHONG" );
	fprintf ( fileout, "    }\n" );
	stats.text_num += 3;
  {
	// MaterialBinding
	fprintf ( fileout, "    MaterialBinding {\n" );
	fprintf ( fileout, "      value %s\n","PER_VERTEX_INDEXED" );
	fprintf ( fileout, "    }\n" );
	stats.text_num += 3;
  }
  {
  //NormalBinding
  //  PER_VERTEX promises that we will write a list of normal vectors
  //    in a particular order, namely, the normal vectors for the vertices
  //    of the first face, then the second face, and so on.
  //  PER_VERTEX_INDEXED promises that we will write a list of normal vectors,
  //    and then, as part of the IndexedFaceSet, we will give a list of
  //    indices referencing this normal vector list.
	fprintf ( fileout, "    NormalBinding {\n" );
	fprintf ( fileout, "      value %s\n","PER_VERTEX_INDEXED" );
	fprintf ( fileout, "    }\n" );
	stats.text_num += 3;
  }
}
/******************************************************************************/

bool IVCONV::iv_write_textureuv ( FILE *fileout )

/******************************************************************************/
/*
Purpose:
  IV_WRITE_TEXTUREUV writes a texture coordinates to an Inventor file.

    Author: John Burkardt
    Modified: 29 June 1999
	Modified: 08 Mar 2007 Tomasz Lis created as new function
*/
{
	// Texture coordinates.
	fprintf ( fileout, "    TextureCoordinate2 {\n" );
	fprintf ( fileout, "      point [\n" );
	stats.text_num += 2;

	unsigned long iface;
	unsigned long ivert;
	for ( iface = 0; iface < face_num; iface++ )
		for ( ivert = 0; ivert < face[iface].order; ivert++ )
        {
            unsigned long vertidx=face[iface].vertices[ivert];
			fprintf ( fileout, "        %f %f,\n", vertex[vertidx].tex_uv[0],
				vertex[vertidx].tex_uv[1] );
			stats.text_num++;
		}
	fprintf ( fileout, "      ]\n" );
	fprintf ( fileout, "    }\n" );
	stats.text_num += 2;
	if (debug)
      printf ( "  IV_WRITE_TEXTUREUV: UV mapping ends at line %lu\n", stats.text_num );
    return true;
}
/******************************************************************************/

bool IVCONV::iv_write_vertices ( FILE *fileout )

/******************************************************************************/
/*
Purpose:
  IV_WRITE_VERTICES writes a vertices list to an Inventor file.

    Author: John Burkardt
    Modified: 29 June 1999
	Modified: 08 Mar 2007 Tomasz Lis created as new function
*/
{
	fprintf ( fileout, "    Coordinate3 {\n" );
	fprintf ( fileout, "      point [\n" );
	stats.text_num += 2;
	unsigned long j;
	for ( j = 0; j < vertex_num; ++j )
    {
		fprintf ( fileout, "        %f %f %f,\n", vertex[j].cor3[0], vertex[j].cor3[1], vertex[j].cor3[2] );
		stats.text_num++;
	}
	fprintf ( fileout, "      ]\n" );
	fprintf ( fileout, "    }\n" );
	stats.text_num += 2;
    return true;
}
/******************************************************************************/

bool IVCONV::iv_write_trmatrix ( FILE *fileout )

/******************************************************************************/
/*
Purpose:
  IV_WRITE_TRMATRIX writes a transform matrix to an Inventor file.

    Author: John Burkardt
    Modified: 29 June 1999
	Modified: 08 Mar 2007 Tomasz Lis created as new function
*/
{
	// Transformation matrix.
	fprintf ( fileout, "    MatrixTransform { matrix\n" );
	fprintf ( fileout, "      %f %f %f %f\n", transform_matrix[0][0],
		transform_matrix[0][1], transform_matrix[0][2], transform_matrix[0][3] );
	fprintf ( fileout, "      %f %f %f %f\n", transform_matrix[1][0],
		transform_matrix[1][1], transform_matrix[1][2], transform_matrix[1][3] );
	fprintf ( fileout, "      %f %f %f %f\n", transform_matrix[2][0],
		transform_matrix[2][1], transform_matrix[2][2], transform_matrix[2][3] );
	fprintf ( fileout, "      %f %f %f %f\n", transform_matrix[3][0],
		transform_matrix[3][1], transform_matrix[3][2], transform_matrix[3][3] );
	fprintf ( fileout, "    }\n" );
	stats.text_num += 6;
	if (debug)
      printf ( "  IV_WRITE_TRMATRIX: Transform matrix ends at line %lu\n", stats.text_num );
    return true;
}
/******************************************************************************/

bool IVCONV::iv_write_material ( FILE *fileout, unsigned long matridx )

/******************************************************************************/
/*
Purpose:
  IV_WRITE_MATERIAL writes one material to an Inventor file.

    Author: John Burkardt
    Modified: 29 June 1999
	Modified: 08 Mar 2007 Tomasz Lis created as new function
*/
{
	// Material.
	vec3 colr;
	fprintf ( fileout, "    Material {\n" );
    colr=material[matridx].ambient;
	fprintf ( fileout, "      ambientColor  %f %f %f\n",colr[0],colr[1],colr[2] );
    colr=material[matridx].rgb;
	fprintf ( fileout, "      diffuseColor  %f %f %f\n",colr[0],colr[1],colr[2] );
    colr=vec3(0.0,0.0,0.0);
	fprintf ( fileout, "      emissiveColor %f %f %f\n",colr[0],colr[1],colr[2] );
    colr=material[matridx].specular;
	fprintf ( fileout, "      specularColor %f %f %f\n",colr[0],colr[1],colr[2] );
	fprintf ( fileout, "      shininess     %f\n",0.2 );
	fprintf ( fileout, "      transparency  %f\n",material[matridx].alpha );
	fprintf ( fileout, "    }\n" );
	stats.text_num += 8;
	if (debug)
      printf ( "  IV_WRITE_MATERIAL: Material %lu ends at line %lu\n",matridx,stats.text_num );
    return true;
}
/******************************************************************************/

bool IVCONV::iv_write ( FILE *fileout )

/******************************************************************************/
/*
Purpose:
  IV_WRITE writes graphics information to an Inventor file.

    Author: John Burkardt
    Modified: 29 June 1999
	Modified: 08 Mar 2007 Tomasz Lis rewritten for new IVCON core
*/
{
  stats.text_num = 0;
  {
	fprintf ( fileout, "#Inventor V2.0 ascii\n" );
	fprintf ( fileout, "\n" );
	stats.text_num += 2;
	fprintf ( fileout, "Separator {\n" );
	fprintf ( fileout, "  Info {\n" );
	fprintf ( fileout, "    string \"%s generated by IVCON.\"\n", fileout_name );
	fprintf ( fileout, "    string \"Original data in file %s.\"\n", filein_name );
	fprintf ( fileout, "  }\n" );
	stats.text_num += 5;
	if (debug)
      printf ( "IV_WRITE: Header ends at line %lu\n", stats.text_num );
  }

  fprintf ( fileout, "  Separator {\n" );
  stats.text_num++;

    //Transform matrix
    iv_write_trmatrix( fileout );

    {	// Materials
      unsigned long matridx;
      for (matridx=0;matridx<material_num;matridx++)
        iv_write_material ( fileout, matridx );
    }

    // Material binding and light model
    iv_write_lmodel_and_matbind ( fileout );

	// Texture2.
	//  FLAW: We can only handle one texture right now.
    if ( texture_num > 0 )
    {
       long textr_idx;
       textr_idx=0;
       iv_write_texture ( fileout, textr_idx );
    }
    { // TextureCoordinateBinding
      fprintf ( fileout, "    TextureCoordinateBinding {\n" );
      fprintf ( fileout, "      value %s\n","PER_VERTEX_INDEXED" );
      fprintf ( fileout, "    }\n" );
      stats.text_num += 3;
    }
    { // ShapeHints
      fprintf ( fileout, "    ShapeHints {\n" );
      fprintf ( fileout, "      vertexOrdering %s\n","COUNTERCLOCKWISE" );
      fprintf ( fileout, "      shapeType      %s\n","UNKNOWN_SHAPE_TYPE" );
      fprintf ( fileout, "      faceType       %s\n","CONVEX" );
      fprintf ( fileout, "      creaseAngle    %f\n",6.28319 );
      fprintf ( fileout, "    }\n" );
      stats.text_num += 6;
    }
    { // Point coordinates.
      iv_write_vertices( fileout );
    }
    { // Texture coordinates.
      iv_write_textureuv( fileout );
    }

	// BaseColor.
	//DISABLED - we need to generate color list. or maybe we don't??
    array<vec3> rgbcolor;
    unsigned long color_num=0;
	if ( color_num > 0 )
    {
       iv_write_basecolor ( fileout,rgbcolor,color_num );
	}
    // Normal vectors.
    // Use the normal vectors associated with vertices.
	if ( face_num > 0 )
    {
      iv_write_vertnormals( fileout );
	}
	// IndexedLineSet
	if ( shape_num > 0 )
    {
         iv_write_lineset( fileout );
	}
    // IndexedFaceSet.
	if ( face_num > 0 )
    {
         iv_write_faceset( fileout );
	}
	// Close up the Separator nodes.
	fprintf ( fileout, "  }\n" );
    stats.text_num++;

  fprintf ( fileout, "}\n" );
  stats.text_num++;

  // Report.
  printf ( "\n" );
  printf ( "IV_WRITE - Wrote %lu text lines;\n", stats.text_num );
  return true;
}
/******************************************************************************/
