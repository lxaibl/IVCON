/******************************************************************************/
// Author:  John Burkardt
// Change: 08 Mar 2007 Tomasz Lis adjusted to new core
// Change: 31 May 2008 Tomasz Lis fixed unclosed bracket

// Purpose:
//   Methods for support of VRML (Virtual Reality Modeling Language) files

// A list of supported elements follows. Please modify if you'll enhance something.
// Format support note - reading:
// - same functionality as in IV format reading
// Format support note - writing:
// - Full 32-bit vertices support
// - Full 32-bit faces support, unlimited face order
// - Meshes supported
// - One material supported
// - One texture supported
// - Texture UV supported (per-face; unverified)
// - No camera/view support
// - No Environment or lights support
// - No shapes support (unfinished)
/*
Example:

#VRML V2.0 utf8

WorldInfo {
title "cube.iv."
string "WRL file generated by IVREAD.
}

Group {
children [

Shape {

appearance Appearance {
material Material {
diffuseColor   0.0 0.0 0.0
emissiveColor  0.0 0.0 0.0
shininess      1.0
}
} #end of appearance

geometry IndexedLineSet {

coord Coordinate {
point [
8.59816       5.55317      -3.05561
8.59816       2.49756      0.000000E+00
...etc...
2.48695       2.49756      -3.05561
]
}

coordIndex [
0     1     2    -1     3     4     5     6     7     8    -
9    10    -1    11    12    -1    13    14    15    -1    1
...etc...
191    -1
]

colorPerVertex TRUE

colorIndex [
0     0     0    -1     2     3     1     1     4     7    -
10     9    -1     7     7    -1     3     2     2    -1    1
...etc...
180    -1
]

}  #end of geometry

}  #end of Shape

]  #end of children

}  #end of Group
*/
//Copying and copyrights:
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2 of the License, or
//   (at your option) any later version.
/******************************************************************************/

#include "ivconv.h"

/******************************************************************************/

bool IVCONV::wrl_write_faceset ( FileIO *fileout, unsigned long mesh_idx )

/******************************************************************************/
/*
Purpose:
  WRL_WRITE_FACESET writes shape InexedFaceSet data to a WRL file.

    Author: John Burkardt
    Modified: 23 May 1999
    Modified: 14 Mar 2007 Tomasz Lis created from WRL_WRITE
*/
{
    array<unsigned long> vert_idx;
    unsigned long vert_count=0;
    array<long> nvert_idx;
    unsigned long faces_count=0;
    get_mesh_vertices(vert_idx,vert_count,nvert_idx,faces_count,mesh_idx);
    fileout->fprintf("        geometry IndexedFaceSet {\n" );
    stats.text_num++;
    {
		// IndexedFaceSet coord
		fileout->fprintf("          coord Coordinate {\n" );
		fileout->fprintf("            point [\n" );
		stats.text_num += 2;
        unsigned long icor3;
        if (debug)
            printf ( "        WRL_WRITE_FACESET: writing %lu points to mesh %lu Coordinate block\n",vert_count,mesh_idx);
		for ( icor3 = 0; icor3 < vert_count; icor3++ )
        {
            unsigned long v_idx=vert_idx[icor3];
			fileout->fprintf("              %f %f %f,\n", vertex[v_idx].cor3[0],
				vertex[v_idx].cor3[1], vertex[v_idx].cor3[2] );
			stats.text_num++;
		}
		fileout->fprintf("            ]\n" );
		fileout->fprintf("          }\n" );
		stats.text_num += 2;
    }

    { // IndexedFaceSet coordIndex.
		fileout->fprintf("          coordIndex [\n" );
		stats.text_num++;
        unsigned long iface;
        if (debug)
            printf ( "        WRL_WRITE_FACESET: writing coordIndex block\n");
        for ( iface = 0; iface < face_num; iface++ )
          if (face[iface].mesh == mesh_idx)
          {
            fileout->fprintf("            " );
            unsigned int order=face[iface].order;
            unsigned int ivert;
	        for ( ivert = 0; ivert < order; ivert++ )
            {
                unsigned long vert_pos=face[iface].vertices[ivert];
                long ver_idx_itm=nvert_idx[vert_pos];
                if (ver_idx_itm>=0)
                  fileout->fprintf("%lu ", ver_idx_itm);
                else
                  if (debug)
                    printf ( "        WRL_WRITE_FACESET: Warning, cannot find one of vertices!\n");
            }
			fileout->fprintf("%d ", -1);
			fileout->fprintf("\n" );
			stats.text_num++;
          }
		fileout->fprintf("          ]\n" );
		stats.text_num++;
    } // End of coordIndex

    { // Colors
		fileout->fprintf("          color Color {\n" );
		fileout->fprintf("            color [\n" );
		stats.text_num += 2;
        unsigned long j;
		for ( j = 0; j < vert_count; ++j )
        {
            unsigned long v_idx=vert_idx[j];
            vec3 colr=vec3(vertex[v_idx].rgb);
			fileout->fprintf("              %f %f %f,\n", colr[0],colr[1],colr[2]);
			stats.text_num++;
		}
		fileout->fprintf("            ]\n" );
		fileout->fprintf("          }\n" );
		stats.text_num += 2;
    }
    //colorPerVertex=TRUE means that we have no colorIndex block,
    // just one color entry per vertex
    //colorPerVertex=FALSE means we have colorIndex block with
    // per-face colors definition
    fileout->fprintf("          colorPerVertex %s\n","TRUE" );
    //texture coordinates support - unfinished
    {
      fileout->fprintf("          texCoord TextureCoordinate {\n" );
      fileout->fprintf("          point [\n" );
      stats.text_num += 2;
      unsigned long ivert;
      for ( ivert = 0; ivert < vert_count; ivert++ )
      {
          unsigned long v_idx=vert_idx[ivert];
          vec2 uvmap=vec2(vertex[v_idx].tex_uv);
		  fileout->fprintf("              %f %f,\n", uvmap[0],uvmap[1]);
          stats.text_num++;
      }
      fileout->fprintf("            ]\n" );
      fileout->fprintf("          }\n" );
      stats.text_num += 2;
      fileout->fprintf("          texCoordIndex [\n" );
      stats.text_num++;
      unsigned long iface;
      for ( iface = 0; iface < face_num; iface++ )
        if (face[iface].mesh == mesh_idx)
        {
            fileout->fprintf("            " );
            unsigned int order=face[iface].order;
            unsigned int ivert;
	        for ( ivert = 0; ivert < order; ivert++ )
            {
                unsigned long vert_pos=face[iface].vertices[ivert];
                long ver_idx_itm=nvert_idx[vert_pos];
                if (ver_idx_itm>=0)
                  fileout->fprintf("%lu ", ver_idx_itm);
                else
                  if (debug)
                    printf ( "        WRL_WRITE_FACESET: Warning, cannot find one of vertices to write UV!\n");
            }
			fileout->fprintf("%d ", -1);
			fileout->fprintf("\n" );
			stats.text_num++;
         }
      fileout->fprintf("          ]\n" );
      stats.text_num++;
    }
    return true;
}
/******************************************************************************/

bool IVCONV::wrl_write_lineset ( FileIO *fileout )

/******************************************************************************/
/*
Purpose:
  WRL_WRITE_LINESET writes shape InexedLineSet data to a WRL file.

    Author: John Burkardt
    Modified: 23 May 1999
    Modified: 14 Mar 2007 Tomasz Lis created from WRL_WRITE
*/
{
    fileout->fprintf("        geometry IndexedLineSet {\n" );
    stats.text_num++;
    array<unsigned long> shape_cor3_base;
    {
		// IndexedLineSet coord
		fileout->fprintf("          coord Coordinate {\n" );
		fileout->fprintf("            point [\n" );
		stats.text_num += 2;
        unsigned long shape_idx;
        unsigned long cor3_count=0;
		for ( shape_idx = 0; shape_idx < shape_num; shape_idx++ )
        {
            shape_cor3_base[shape_idx]=cor3_count;
            unsigned long shp_order=shape[shape_idx].order;
            unsigned long icor3;
            for ( icor3 = 0; icor3 < shp_order; icor3++ )
            {
              vec3 vcor3=vec3(shape[shape_idx].cor3[icor3]);
              fileout->fprintf("              %f %f %f\n",vcor3[0],vcor3[1],vcor3[2] );
              stats.text_num++;
              cor3_count++;
            }
        }
		fileout->fprintf("            ]\n" );
		fileout->fprintf("          }\n" );
		stats.text_num += 2;
    }
    { // IndexedLineSet coordIndex.
        fileout->fprintf("          coordIndex [\n" );
        stats.text_num++;
        unsigned long shape_idx;
		for ( shape_idx = 0; shape_idx < shape_num; shape_idx++ )
        {
            fileout->fprintf("            " );
            unsigned long shp_order=shape[shape_idx].order;
            unsigned long icor3;
            for ( icor3 = 0; icor3 < shp_order; icor3++ )
			    fileout->fprintf("%lu ", shape_cor3_base[shape_idx] );
            fileout->fprintf("%d \n",-1);
            stats.text_num++;
        }
		fileout->fprintf("          ]\n" );
		stats.text_num++;
    }
    { // Colors
		fileout->fprintf("          color Color {\n" );
		fileout->fprintf("            color [\n" );
		stats.text_num += 2;
        unsigned long j;
		for ( j = 0; j < shape_num; ++j )
        {
            vec3 colr=vec3(shape[j].rgb);
			fileout->fprintf("              %f %f %f,\n", colr[0],colr[1],colr[2]);
			stats.text_num++;
		}
		fileout->fprintf("            ]\n" );
		fileout->fprintf("          }\n" );
		stats.text_num += 2;
    }
    //colorPerVertex=TRUE means that we have no colorIndex block,
    // just one color entry per vertex
    //colorPerVertex=FALSE means we have colorIndex block with
    // per-face colors definition
    fileout->fprintf("          colorPerVertex %s\n","FALSE" );
    stats.text_num ++;
    { // IndexedLineset colorIndex
		fileout->fprintf("          colorIndex [\n" );
		stats.text_num ++;
        fileout->fprintf("            " );
        unsigned long shape_idx;
		for ( shape_idx = 0; shape_idx < shape_num; shape_idx++ )
           	  fileout->fprintf("%lu ", shape_idx );
        fileout->fprintf("\n" );
		stats.text_num++;
		fileout->fprintf("          ]\n" );
        stats.text_num++;
    }
    fileout->fprintf("        }\n" );
    stats.text_num++;
    return true;
}
/******************************************************************************/

bool IVCONV::wrl_write_shapes ( FileIO *fileout )

/******************************************************************************/
/*
Purpose:
  WRL_WRITE_SHAPE writes shape data to a WRL file.

Author: John Burkardt
Modified: 23 May 1999
Modified: 14 Mar 2007 Tomasz Lis created from WRL_WRITE
Modified: 31 May 2008 Tomasz Lis Fixed brackets
*/
{
  fileout->fprintf("      Shape {\n" );
  stats.text_num++;
  {
    unsigned long matr_idx=0;
	fileout->fprintf("        appearance Appearance {\n" );
	long textr_idx=material[matr_idx].texture;
	if (textr_idx>=0)
      fileout->fprintf("          texture ImageTexture { url \"%s\" }\n",texture[textr_idx].name );
	fileout->fprintf("          material Material {\n" );
	fileout->fprintf("            diffuseColor   %f %f %f\n",
            material[matr_idx].rgb[0],material[matr_idx].rgb[1],material[matr_idx].rgb[2] );
	fileout->fprintf("            emissiveColor  %f %f %f\n",
            material[matr_idx].specular[0],material[matr_idx].specular[1],material[matr_idx].specular[2] );
	fileout->fprintf("            shininess      %f\n",1.0 );
	fileout->fprintf("          }\n" );
	fileout->fprintf("        }\n" );
	stats.text_num+=7;
    if (debug)
	  printf ( "  WRL_WRITE_SHAPE: Appearance block for shapes ends at line %lu\n",stats.text_num );
  }

  // IndexedLineSet
  wrl_write_lineset( fileout );
  // End of IndexedLineSet
  if (debug)
	  printf ( "  WRL_WRITE_SHAPE: IndexedLineSet block for shapes end at line %lu\n",stats.text_num );

  //  End of Shape
  fileout->fprintf("      }\n" );
    return true;
}
/******************************************************************************/

bool IVCONV::wrl_write_mesh ( FileIO *fileout, unsigned long mesh_idx )

/******************************************************************************/
/*
Purpose:

WRL_WRITE_MESH writes shape data to a WRL file.

Author: John Burkardt
Modified: 23 May 1999
Modified: 14 Mar 2007 Tomasz Lis created from WRL_WRITE
*/
{
  fileout->fprintf("      Shape {\n" );
  stats.text_num++;
  {
    unsigned long matr_idx=0;
	fileout->fprintf("        appearance Appearance {\n" );
    stats.text_num++;
	long textr_idx=material[matr_idx].texture;
	if (textr_idx>=0)
	{
      fileout->fprintf("          texture ImageTexture { url \"%s\" }\n",texture[textr_idx].name );
      stats.text_num++;
    }
    // Writing material
	fileout->fprintf("          material Material {\n" );
	fileout->fprintf("            diffuseColor   %f %f %f\n",
            material[matr_idx].rgb[0],material[matr_idx].rgb[1],material[matr_idx].rgb[2] );
	fileout->fprintf("            emissiveColor  %f %f %f\n",
            material[matr_idx].specular[0],material[matr_idx].specular[1],material[matr_idx].specular[2] );
	fileout->fprintf("            shininess      %f\n",1.0 );
	fileout->fprintf("          }\n" );
	stats.text_num+=5;
    // end Appearance
	fileout->fprintf("        }\n" );
	stats.text_num++;
    // end Shape
	fileout->fprintf("    }\n" );
	stats.text_num++;
    if (debug)
	  printf ( "  WRL_WRITE_MESH: Appearance block for mesh %lu end at line %lu\n",mesh_idx,stats.text_num );
  }

  // IndexedFaceSet
  wrl_write_faceset( fileout,mesh_idx );
  // End of IndexedFaceSet
  if (debug)
	  printf ( "  WRL_WRITE_MESH: IndexedFaceSet block for mesh %lu end at line %lu\n",mesh_idx,stats.text_num );

  //  End of Shape
  fileout->fprintf("      }\n" );
    return true;
}
/******************************************************************************/

bool IVCONV::wrl_write ( FileIO *fileout )

/******************************************************************************/
/*
Purpose:
  WRL_WRITE writes graphics data to a WRL file.

    Author: John Burkardt
    Modified: 23 May 1999
    Modified: 14 Mar 2007 Tomasz Lis adjusted to new core and extended
*/
{
	stats.text_num = 0;
	
	fileout->fprintf("#VRML %s %s\n","V2.0","utf8");
	fileout->fprintf("\n" );
	fileout->fprintf("  WorldInfo {\n" );
	fileout->fprintf("    title \"%s\"\n", fileout_name );
	fileout->fprintf("    info \"WRL file generated by IVREAD.\"\n" );
	fileout->fprintf("    info \"Original data in %s\"\n", filein_name );
	fileout->fprintf("  }\n" );
	fileout->fprintf("\n" );
	stats.text_num+=8;
    if (debug)
	  printf ( "WRL_WRITE: WorldInfo block end at line %lu\n", stats.text_num );

	fileout->fprintf("  Viewpoint {\n" );
	fileout->fprintf("    description \"%s\"\n", "Initial view" );
	fileout->fprintf("    position %f %f %f\n",0.0f,0.0f,9.0f );
	fileout->fprintf("  }\n" );
	fileout->fprintf("\n" );
	stats.text_num+=5;
    if (debug)
	  printf ( "WRL_WRITE: Viewpoint block end at line %lu\n", stats.text_num );


	fileout->fprintf("  Group {\n" );
	fileout->fprintf("    children [\n" );
	stats.text_num+=2;

    unsigned long i;
    for (i=0;i<mesh_num;i++)
      wrl_write_mesh ( fileout,i );

    wrl_write_shapes ( fileout );

	//  End of children
	  fileout->fprintf("    ]\n" );
	//  End of Group
	  fileout->fprintf("  }\n" );
	  stats.text_num+=2;

	  // Report.
	  printf ( "\n" );
	  printf ( "WRL_WRITE: Wrote %lu text lines.\n", stats.text_num );
	  
    return true;
}
/******************************************************************************/

